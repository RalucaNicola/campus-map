<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Hand drawn campus map</title>

    <link rel="stylesheet" href="https://js.arcgis.com/4.19/esri/themes/light/main.css" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@700&display=swap" rel="stylesheet" />
    <script src="https://js.arcgis.com/4.19/"></script>

    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      canvas {
        filter: saturate(1.6);
      }
    </style>

    <script>
      require([
        "esri/layers/FeatureLayer",
        "esri/layers/SceneLayer",
        "esri/Graphic",
        "esri/WebScene",
        "esri/views/SceneView",
        "esri/tasks/support/Query",
        "esri/tasks/QueryTask",
        "esri/geometry/support/MeshComponent",
        "esri/symbols/MeshSymbol3D",
        "esri/geometry/Mesh",
        "esri/layers/GraphicsLayer",
        "esri/geometry/Polygon",
        "esri/geometry/Point",
        "esri/geometry/SpatialReference",
        "esri/layers/support/LabelClass",
        "esri/geometry/support/MeshMaterialMetallicRoughness",
      ], function (
        FeatureLayer,
        SceneLayer,
        Graphic,
        WebScene,
        SceneView,
        Query,
        QueryTask,
        MeshComponent,
        MeshSymbol3D,
        Mesh,
        GraphicsLayer,
        Polygon,
        Point,
        SpatialReference,
        LabelClass,
        MeshMaterialMetallicRoughness
      ) {
        const webscene = new WebScene({
          ground: {
            surfaceColor: "white",
          },
        });

        const sceneLayer = new SceneLayer({
          url: "https://tiles.arcgis.com/tiles/V6ZHFr6zdgNZuVG0/arcgis/rest/services/campus_buildings_sketch/SceneServer",
          screenSizePerspectiveEnabled: true,
          renderer: {
            type: "simple",
            symbol: {
              type: "mesh-3d",
              symbolLayers: [
                {
                  type: "fill",
                  material: { color: "white" },
                  edges: {
                    type: "sketch",
                    color: [50, 50, 50, 1],
                    size: 1,
                    extensionLength: 5,
                  },
                },
              ],
            },
          },
          popupTemplate: {
            title: "",
            content: "Building: {NAME}",
          },
          labelsVisible: true,
          labelingInfo: [
            new LabelClass({
              labelExpressionInfo: { expression: "$feature.name" },
              symbol: {
                type: "label-3d",
                symbolLayers: [
                  {
                    type: "text",
                    material: {
                      color: [50, 50, 50, 1],
                    },
                    halo: {
                      size: 2,
                      color: [255, 255, 255, 0.8],
                    },
                    font: {
                      size: 14,
                      family: `'Amatic SC', sans-serif`,
                    },
                  },
                ],
                verticalOffset: {
                  screenLength: 20,
                  maxWorldLength: 200,
                  minWorldLength: 0,
                },
                callout: {
                  type: "line",
                  size: 1,
                  color: [50, 50, 50],
                  border: {
                    color: [0, 0, 0, 0],
                  },
                },
              },
            }),
          ],
        });
        webscene.add(sceneLayer);

        const treeLayer = new GraphicsLayer({
          elevationInfo: {
            mode: "relative-to-ground",
          },
        });
        webscene.add(treeLayer);

        // Loading trees as a mesh, so that we can apply sketch edges
        const queryTreeTask = new QueryTask({
          url: "https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Campus_features/FeatureServer/0",
        });

        queryTreeTask
          .execute({
            returnZ: true,
            returnGeometry: true,
            outFields: ["Class", "Height", "Rotation"],
            where: "1=1",
          })
          .then((result) => {
            for (let i = 0; i < result.features.length; i++) {
              const location = result.features[i].geometry;
              const type = result.features[i].attributes["Class"];
              const size = result.features[i].attributes["Height"];
              const rotation = result.features[i].attributes["Rotation"];
              const url = type === "Eucalyptus" ? "../assets/trees/Apricot.glb" : "../assets/trees/Leyland_Cypress.glb";

              // Function that converts a polygon into a 3D mesh geometry
              Mesh.createFromGLTF(location, url)
                .then(function (mesh) {
                  // color tree leafs
                  mesh.components[1].material = new MeshMaterialMetallicRoughness({
                    color: [191, 207, 157],
                    roughness: 1,
                    metallic: 0,
                  });
                  // color trunk
                  mesh.components[0].material = new MeshMaterialMetallicRoughness({
                    color: [204, 175, 124],
                    roughness: 1,
                    metallic: 0,
                  });
                  const scale = type === "Eucalyptus" ? 0.15 : 0.2;
                  mesh.scale(size * scale, { origin: location });
                  mesh.rotate(0, 0, rotation);

                  treeLayer.add(
                    new Graphic({
                      geometry: mesh,
                      symbol: {
                        type: "mesh-3d",
                        symbolLayers: [
                          {
                            type: "fill",
                            edges: {
                              type: "sketch",
                              color: [50, 50, 50, 0.6],
                              size: 1,
                              extensionLength: 5,
                            },
                          },
                        ],
                      },
                    })
                  );
                })
                .catch(console.error);
            }
          });

        const areasLayer = new SceneLayer({
          url: "https://tiles.arcgis.com/tiles/V6ZHFr6zdgNZuVG0/arcgis/rest/services/campus_basemap_patterns/SceneServer",
          elevationInfo: {
            mode: "absolute-height",
            offset: 0.1,
          },
          renderer: {
            type: "simple",
            symbol: {
              type: "mesh-3d",
              symbolLayers: [
                {
                  type: "fill",
                  edges: {
                    type: "sketch",
                    color: [50, 50, 50, 1],
                    size: 1,
                    extensionLength: 5,
                  },
                  castShadows: false,
                },
              ],
            },
          },
        });
        webscene.add(areasLayer);

        const pedestrianAreaLayer = new GraphicsLayer();
        webscene.add(pedestrianAreaLayer);

        const queryTask = new QueryTask({
          url: "https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Campus_features/FeatureServer/2",
        });

        queryTask
          .execute({
            returnZ: true,
            returnGeometry: true,
            where: "Class='Pedestrian'",
          })
          .then((result) => {
            for (let i = 0; i < result.features.length; i++) {
              console.log(result);
              const area = result.features[i].geometry;

              // Function that converts a polygon into a 3D mesh geometry
              const mesh = Mesh.createFromPolygon(area);

              pedestrianAreaLayer.add(
                new Graphic({
                  geometry: mesh,
                  symbol: {
                    type: "mesh-3d",
                    symbolLayers: [
                      {
                        type: "fill",
                        material: {
                          color: [0, 0, 0, 0],
                        },
                        edges: {
                          type: "sketch",
                          color: [50, 50, 50, 1],
                          size: 1,
                          extensionLength: 5,
                        },
                      },
                    ],
                  },
                })
              );
            }
          });

        const poi = new FeatureLayer({
          url: "https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/CampusPOI/FeatureServer",
          screenSizePerspectiveEnabled: true,
          renderer: {
            type: "unique-value",
            field: "Class",
            uniqueValueInfos: [
              {
                value: "Parking",
                symbol: {
                  type: "point-3d",
                  symbolLayers: [
                    {
                      type: "icon",
                      resource: { href: "./parking-icon.png" },
                      material: { color: [255, 255, 255] },
                      size: 40,
                    },
                  ],
                  verticalOffset: {
                    screenLength: 20,
                    maxWorldLength: 10000,
                    minWorldLength: 5,
                  },
                  callout: {
                    type: "line",
                    size: 1,
                    color: [50, 50, 50, 1],
                    border: {
                      color: [0, 0, 0, 0],
                    },
                  },
                },
              },
            ],
          },
        });
        webscene.add(poi);

        const view = new SceneView({
          container: "viewDiv",
          qualityProfile: "high",
          map: webscene,
          viewingMode: "global",
          environment: {
            lighting: {
              date: "Mon January 15 2021 19:30:00 GMT+0100 (Central European Standard Time)",
            },
          },
          camera: {
            position: [-88.97955612, 39.83921313, 149.51383],
            heading: 45.34,
            tilt: 70.69,
          },
          highlightOptions: {
            color: "#505050",
          },
        });

        view.environment.lighting.ambientOcclusionEnabled = false;
        view.environment.lighting.directShadowsEnabled = true;
      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
  </body>
</html>
